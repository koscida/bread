<!DOCTYPE html>
<html>
	<head>
		<!-- Meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<!-- jQuery -->
		<script src="https://releases.jquery.com/git/jquery-3.x-git.min.js" crossorigin="anonymous"></script>		
		
		<!-- Bootstrap CSS -->
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

		<!-- Font Awesome -->
		<script src="https://kit.fontawesome.com/126a06fcac.js" crossorigin="anonymous"></script>

		<!-- Custom CSS -->
		<style>
			/* Prevent scrolling */
            html, body {
                overflow: hidden;
                height: 100%;
            }

			#canvas {
				border: 1px solid #000;
				box-sizing: border-box;
				margin: 0;
				padding: 0;
			}
		</style>
	</head>
	<body>
		<div class="container-fluid">
			<div class="row">
				<!-- Left Column -->
				<div class="col-2 bg-light">
					<h3>Left Column</h3>
					<p>Content for the left column goes here.</p>

					<!-- Energy Bar Values Display -->
					<div id="energy-display">
						<p>Top Energy: <span id="top-energy-value">0</span></p>
						<p>Bottom Energy: <span id="bottom-energy-value">0</span></p>
					</div>

					<!-- Bowl Size Display -->
					<div id="circle-diameter-display">
						<p>Large Bowl Width: <span id="large-bowl-width">0</span></p>
						<p>Large Bowl Height: <span id="large-bowl-height">0</span></p>

						<p>Small Bowl Width: <span id="small-bowl-width">0</span></p>
						<p>Small Bowl Height: <span id="small-bowl-height">0</span></p>
						
						<p>Spout Width: <span id="spout-width">0</span></p>
						<p>Spout Height: <span id="spout-height">0</span></p>
					</div>

					<!-- Game State Display -->
					<div id="game-state-display">
						<p>Current State: <span id="current-state">Mixing</span></p>
						<button id="next-state-button" class="btn btn-primary">Next Stage</button>
					</div>

				</div>

				<!-- Center Column -->
				<div class="col-8" id="canvas-container">
					<!-- Canvas Element -->
					<canvas id="canvas" style="border:1px solid #000; width: 100%;"></canvas>
				</div>

				<!-- Right Column -->
				<div class="col-2 bg-light">
					<h3>Right Column</h3>
					<p>Content for the right column goes here.</p>
					<i class="fa-solid fa-2x">&#x42;</i>
					<i class="fa-regular fa-2x fa-spin">&#xf436;</i>
					<i class="fa-duotone fa-solid fa-2x fa-shake">&#xf437;</i>
					<i class="fa-light fa-2x">&#x31;</i>
					<i class="fa-sharp fa-solid fa-2x">&#x58;</i>
					<i class="fa-sharp-duotone fa-solid fa-2x">&#xf725;</i>
				</div>
			</div>
		</div>
		
		<!-- Bootstrap JS -->
		<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>

		<script>
			/* 
			0: help, sit, kin
			1: cont/dia, gro
			2: crow/rof
			3: sp, re-do, hold
			*/

			$(document).ready(function() {
				// Canvas size
				let canvasWidth = 0;
				let canvasHeight = 0;

				// HUD
				let hudWidth = canvasWidth;
				let hudHeight = 50;
				let barWidth = canvasWidth * 0.3; // 30% of the HUD width;
				let	barHeight = 15; // 15px height
				let	spacing = 5; // 5px spacing between elements
				let hudTimerOffset = 150; // Offset for the timer bar

				// Energy bar values (0 to 100)
				let topEnergy = 100; // Initial value for the top energy bar
				let bottomEnergy = 100; // Initial value for the bottom energy bar

				// Game states
				const gameStates = ['Mixing', 'Proofing', 'Baking'];
    			let gameStateIndex = 0; // Start with the first state

				// Timer variables
				let timerDuration = [30, 120, 60]; // 2 minutes in seconds
				let timerRemaining = timerDuration[gameStateIndex]; // Time remaining for the current state
				let timerPaused = false; // Track whether the timer is paused
				let timerStopped = false; // Track whether the timer is stopped

				// Variables to control the diameters of the large bowl
				let largeBowlStartWidth = 50; // Starting width of the large bowl
				let largeBowlMaxWidth = 400; // Max width of the large bowl
				let largeBowlWidth = largeBowlStartWidth; // Initial width of the large bowl
				let largeBowlStartHeight = largeBowlStartWidth; // Starting height of the large bowl
				let largeBowlMaxHeight = largeBowlMaxWidth; // Max height of the large bowl
				let largeBowlHeight = largeBowlStartHeight; // Initial height of the large bowl

				// Variables to control the diameters of the small bowl
				let smallBowlAreaTarget = 10000;
				let smallBowlStartWidth = 50; // Starting width of the small bowl
				let smallBowlStartHeight = smallBowlAreaTarget / smallBowlStartWidth; // Starting height of the small bowl
				let smallBowlWidth = smallBowlStartWidth; // Initial width of the small bowl
				let smallBowlHeight = smallBowlStartHeight; // Initial height of the small bowl

				// Variables to control the dimensions of the spout
				let spoutAreaTarget = 10000;
				let spoutWidth = smallBowlWidth; // Initial width of the spout
				let spoutHeight = spoutAreaTarget / spoutWidth; // Initial height of the spout

				// Variables for button dimensions and positions
				const buttonWidth = 80;
				const buttonHeight = 30;
				const buttonY = hudHeight + 10; // Position below the HUD
				let buttons = [
					{ label: 'Rewind', x: 10, action: 'rewind' },
					{ label: 'Pause', x: 100, action: 'pause' },
					{ label: 'Play', x: 190, action: 'play' },
					{ label: 'Stop', x: 280, action: 'stop' },
					{ label: 'Fast Forward', x: 370, action: 'fast-forward' },
				];

				// Color
				let hue = 0; // Initialize hue value
                const saturation = 100; // Saturation percentage
                const lightness = 50; // Lightness percentage


				// // // // // // //
				// Update

				// Function to update the game state display
				function updateGameStateDisplay() {
					const currentState = gameStates[gameStateIndex];
					$('#current-state').text(currentState); // Update the HUD and left column
				}

				// Function to update the circle diameter display
				function updateBowlDisplay() {
					$('#large-bowl-width').text(largeBowlWidth); // Update top circle diameter
					$('#large-bowl-height').text(largeBowlHeight); // Update top circle diameter
					$('#small-bowl-width').text(smallBowlWidth); // Update bottom circle diameter
					$('#small-bowl-height').text(smallBowlHeight); // Update bottom circle diameter
					$('#spout-width').text(spoutWidth); // Update rectangle width
					$('#spout-height').text(spoutHeight); // Update rectangle height
				}


				// Function to update the timer bar
				function updateTimer() {
					if (!timerPaused && !timerStopped) {
						// Decrease the timer
						timerRemaining--;

						// Update spout dimensions during the Proofing state
						updateBowlDimensions();

						// If the timer reaches 0, move to the next game state
						if (timerRemaining <= 0) {
							gameStateIndex = (gameStateIndex + 1) % gameStates.length; // Move to the next state
							updateGameStateDisplay();
							timerRemaining = timerDuration[gameStateIndex]; // Reset the timer for the next state
						}
					}
				}

				// Function to update the spout dimensions during the Proofing state
				function updateBowlDimensions() {
					// Calculate the progress of the timer (0 to 1)
					const timerProgress = timerRemaining / timerDuration[gameStateIndex];

					// Set bowl and spout dimensions based on the current game state
					if (gameStateIndex === 0) {
						// Update large bowl based on timer progress
						largeBowlWidth = largeBowlStartWidth + (largeBowlMaxWidth - largeBowlStartWidth) * (1 - timerProgress);
						largeBowlHeight = largeBowlStartHeight + (largeBowlMaxHeight - largeBowlStartHeight) * (1 - timerProgress);
					} else if (gameStateIndex === 1) {
						// // Update spoutWidth based on timer progress
						// smallBowlWidth = smallBowlStartWidth + (smallBowlMaxWidth - smallBowlStartWidth) * (1 - timerProgress);
						// smallBowlHeight = smallBowlStartHeight + (smallBowlMaxHeight - smallBowlStartHeight) * (1 - timerProgress);

						// // Update spoutWidth based on timer progress
						// spoutWidth = smallBowlWidth + (0.6 * largeBowlWidth - smallBowlWidth) * (1 - timerProgress);
						// // Calculate spoutHeight to maintain an area
						// spoutHeight = spoutAreaTarget / spoutWidth; // Calculate height based on width
					} else {
						
					}
				}


				// // // // // // //
				// Draw

				// Function to redraw the canvas
                function redrawCanvas() {
					const ctx = canvas.getContext('2d');

					// Clear the canvas
                    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

                    // Draw the bowl
					drawBowl(ctx)

					// Draw the HUD
                    drawHUD(ctx);
                }

				// Function to draw the Bowl
                function drawBowl(ctx) {
					// Calculate the center positions
					const centerX = canvasWidth / 2;
					const centerY = (canvasHeight - hudHeight) / 2;
					
					// Draw the large bowl (top rounded square)
					const largeBowlX = centerX - largeBowlWidth / 2; // Top-left X position
					const largeBowlY = centerY - (largeBowlHeight / 2) - (spoutHeight / 2); // Top-left Y position
					const largeBowlRadius = Math.min(largeBowlWidth, largeBowlHeight) / 4; // Radius for rounded corners
					ctx.beginPath();
					ctx.moveTo(largeBowlX + largeBowlRadius, largeBowlY);
					ctx.lineTo(largeBowlX + largeBowlWidth - largeBowlRadius, largeBowlY);
					ctx.quadraticCurveTo(largeBowlX + largeBowlWidth, largeBowlY, largeBowlX + largeBowlWidth, largeBowlY + largeBowlRadius);
					ctx.lineTo(largeBowlX + largeBowlWidth, largeBowlY + largeBowlHeight - largeBowlRadius);
					ctx.quadraticCurveTo(largeBowlX + largeBowlWidth, largeBowlY + largeBowlHeight, largeBowlX + largeBowlWidth - largeBowlRadius, largeBowlY + largeBowlHeight);
					ctx.lineTo(largeBowlX + largeBowlRadius, largeBowlY + largeBowlHeight);
					ctx.quadraticCurveTo(largeBowlX, largeBowlY + largeBowlHeight, largeBowlX, largeBowlY + largeBowlHeight - largeBowlRadius);
					ctx.lineTo(largeBowlX, largeBowlY + largeBowlRadius);
					ctx.quadraticCurveTo(largeBowlX, largeBowlY, largeBowlX + largeBowlRadius, largeBowlY);
					ctx.closePath();
					ctx.fillStyle = '#FF5733'; // Example color for the large bowl
					ctx.fill();


					// Draw the spout (rectangle between the two bowls)
					const spoutX = centerX - spoutWidth / 2; // Center the spout horizontally
					const spoutY = largeBowlY + largeBowlHeight; // Position the spout to touch the bottom of the large bowl
					ctx.fillStyle = '#00FF00'; // Example color for the spout
					ctx.fillRect(spoutX, spoutY, spoutWidth, spoutHeight);


					// Draw the small bowl (bottom rounded square)
					const smallBowlX = centerX - smallBowlWidth / 2; // Top-left X position
					const smallBowlY = spoutY + spoutHeight; // Top-left Y position
					const smallBowlRadius = Math.min(smallBowlWidth, smallBowlHeight) / 4; // Radius for rounded corners
					ctx.beginPath();
					ctx.moveTo(smallBowlX + smallBowlRadius, smallBowlY);
					ctx.lineTo(smallBowlX + smallBowlWidth - smallBowlRadius, smallBowlY);
					ctx.quadraticCurveTo(smallBowlX + smallBowlWidth, smallBowlY, smallBowlX + smallBowlWidth, smallBowlY + smallBowlRadius);
					ctx.lineTo(smallBowlX + smallBowlWidth, smallBowlY + smallBowlHeight - smallBowlRadius);
					ctx.quadraticCurveTo(smallBowlX + smallBowlWidth, smallBowlY + smallBowlHeight, smallBowlX + smallBowlWidth - smallBowlRadius, smallBowlY + smallBowlHeight);
					ctx.lineTo(smallBowlX + smallBowlRadius, smallBowlY + smallBowlHeight);
					ctx.quadraticCurveTo(smallBowlX, smallBowlY + smallBowlHeight, smallBowlX, smallBowlY + smallBowlHeight - smallBowlRadius);
					ctx.lineTo(smallBowlX, smallBowlY + smallBowlRadius);
					ctx.quadraticCurveTo(smallBowlX, smallBowlY, smallBowlX + smallBowlRadius, smallBowlY);
					ctx.closePath();
					ctx.fillStyle = '#33C1FF'; // Example color for the small bowl
					ctx.fill();

					// Update the circle and rectangle dimension displays
					updateBowlDisplay();
				}

				// Function to draw the HUD
                function drawHUD(ctx) {
					// Draw HUD background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(0, 0, hudWidth, hudHeight);

                    // Draw current game state
					drawGameState(ctx);

					// Draw the timer
    				drawTimer(ctx);

					// Draw the energy bars
					drawEnergyBars(ctx)
					
                }

				// Function to draw the game state
				function drawGameState(ctx) {
					// Draw the current game state
					const gameStateFontSize = 20;
					const gameStateY = hudHeight / 2; // Y position of the game state text
					const gameStateX = hudTimerOffset / 2; // X position of the game state text
					ctx.fillStyle = '#FFFFFF';
					ctx.font = gameStateFontSize + 'px Arial';
					ctx.textAlign = 'center'; // Center-align the text
					ctx.fillText(gameStates[gameStateIndex], gameStateX, gameStateY);
				}

				// Function to draw the Timer
				function drawTimer(ctx) {
					// Draw the timer bar
					const timerBarWidth = (barWidth * timerRemaining) / timerDuration[gameStateIndex]; // Scale width based on remaining time
					const timerBarX = hudTimerOffset; // Position the timer bar to the right of the game state
					const timerBarY = spacing; // Y position of the timer bar

					// Draw the background (light grey bar)
					ctx.fillStyle = '#D3D3D3'; // Light grey color
					ctx.fillRect(timerBarX, timerBarY, barWidth, barHeight);

					// Draw the timer bar (foreground)
					ctx.fillStyle = '#FFD700'; // Example color for the timer bar
					ctx.fillRect(timerBarX, timerBarY, timerBarWidth, barHeight);

					// Draw the timer buttons (circles	)
					buttons.forEach((button, index) => {
						// Draw circles under the timer bar
						const circleDiameter = barHeight; // Radius is half the barHeight
						const circleRadius = circleDiameter / 2; // Radius is half the barHeight
						const circleX = timerBarX + (index * (circleDiameter + (spacing * 2))) + circleRadius; // Align circles horizontally under the timer bar
						const circleY = timerBarY + barHeight + spacing + circleRadius; // Position the circles just below the timer bar
						
						// Draw the circle
						ctx.beginPath();
						ctx.arc(circleX, circleY, circleRadius, 0, Math.PI * 2);
						ctx.fillStyle = '#AAAAAA'; // Light grey color for the circle
						ctx.fill();
						ctx.strokeStyle = '#000000'; // Black border for the circle
						ctx.stroke();
					});

					// Draw the play icon
    				drawFontAwesomeIcon(ctx, '\uf04b', 100, 100, 30, '#000000'); // Play icon
					// Draw the pause icon
					drawFontAwesomeIcon(ctx, '\uf04c', 150, 100, 30, '#000000'); // Pause icon
					// Draw the stop icon
					drawFontAwesomeIcon(ctx, '\uf04d', 200, 100, 30, '#000000'); // Stop icon
				}

				// Function to draw the energy bars
				function drawEnergyBars(ctx) {
					// Calculate rectangle dimensions
					const bottomRectY = spacing + barHeight + spacing; // Bottom rectangle's Y position

					// Draw top energy bar
					ctx.fillStyle = topEnergy > 0 ? '#FF5733' : '#D3D3D3'; // Full color if > 0, light grey if 0
					const topBarWidth = (barWidth * topEnergy) / 100; // Scale width based on energy value
					ctx.fillRect(hudWidth - barWidth - spacing, spacing, topBarWidth, barHeight);

					// Label for top energy bar
					ctx.fillStyle = '#FFFFFF'; // White color for the label
					ctx.font = '15px Arial';
					ctx.textAlign = 'right'; // Align text to the right
					ctx.textBaseline = 'middle'; // Vertically center the text
					ctx.fillText('A', hudWidth - barWidth - spacing - spacing, spacing + barHeight / 2);


					// Draw bottom energy bar
					ctx.fillStyle = bottomEnergy > 0 ? '#33C1FF' : '#D3D3D3'; // Full color if > 0, light grey if 0
					const bottomBarWidth = (barWidth * bottomEnergy) / 100; // Scale width based on energy value
					ctx.fillRect(hudWidth - barWidth - spacing, bottomRectY, bottomBarWidth, barHeight);

					// Label for bottom energy bar
					ctx.fillStyle = '#FFFFFF'; // White color for the label
					ctx.font = '15px Arial';
					ctx.textAlign = 'right'; // Align text to the right
					ctx.textBaseline = 'middle'; // Vertically center the text
					ctx.fillText('B', hudWidth - barWidth - spacing - spacing, bottomRectY + barHeight / 2);
				}

				// Helper function to draw Font Awesome icons
				function drawFontAwesomeIcon(ctx, iconUnicode, x, y, size, color) {
					// Set the font to Font Awesome
					ctx.font = `${size}px "Font Awesome 5 Free"`;
					ctx.fillStyle = color; // Set the color of the icon
					ctx.textAlign = 'center'; // Center the icon horizontally
					ctx.textBaseline = 'middle'; // Center the icon vertically

					// Draw the icon using its Unicode
					ctx.fillText(iconUnicode, x, y);
				}


				// // // // // // //
				// Handlers

				// Function to handle button clicks
				function handleButtonClick(event) {
					const canvas = document.getElementById('canvas');
					const rect = canvas.getBoundingClientRect();
					const mouseX = event.clientX - rect.left;
					const mouseY = event.clientY - rect.top;

					buttons.forEach((button) => {
						if (
							mouseX >= button.x &&
							mouseX <= button.x + buttonWidth &&
							mouseY >= buttonY &&
							mouseY <= buttonY + buttonHeight
						) {
							// Perform the action associated with the button
							if (button.action === 'pause') {
								timerPaused = true;
							} else if (button.action === 'play') {
								timerPaused = false;
								timerStopped = false;
							} else if (button.action === 'stop') {
								timerPaused = true;
								timerStopped = true;
								timerRemaining = timerDuration[gameStateIndex];
							} else if (button.action === 'fast-forward') {
								if (!timerStopped) {
									timerRemaining = Math.max(0, timerRemaining - 10);
								}
							} else if (button.action === 'rewind') {
								if (!timerStopped) {
									timerRemaining = Math.min(timerDuration[gameStateIndex], timerRemaining + 10);
								}
							}
						}
					});
				}
				// Add event listener for canvas clicks
				$('#canvas').click(handleButtonClick);

				// Event listener for the "Next Stage" button
				$('#next-state-button').click(function () {
					gameStateIndex = (gameStateIndex + 1) % gameStates.length; // Move to the next state
					updateGameStateDisplay();
					timerRemaining = timerDuration[gameStateIndex];
				});


				// Set canvas size to match the right column size
				function resizeCanvas() {
					canvasWidth = $('#canvas-container').width();
					canvasHeight = $(window).height() - 1;
					$('#canvas').attr('width', canvasWidth);
					$('#canvas').attr('height', canvasHeight);

					hudWidth = canvasWidth;
					barWidth = canvasWidth * 0.3; 
				}
				// Resize canvas on document load
				resizeCanvas();
				// Resize canvas on window resize
				$(window).resize(function() {
					resizeCanvas();
				});


				// // // // // // //
				// Set Intervals

				// Set a timer to redraw the canvas every 100 milliseconds
                setInterval(redrawCanvas, 100);

				// Update the timer every second
				setInterval(updateTimer, 1000);
			});
		</script>
	</body>
</html>
